# SQLC Demonstration - Code Generation Approach

## Overview
`sqlc` is a **code generator** that reads your SQL queries and generates type-safe Go code. It:
- ✅ Eliminates redundancy in repos (generates code automatically)
- ✅ Eliminates redundancy in entities (generates structs from SQL)
- ✅ Type-safe at compile-time
- ✅ No runtime reflection overhead
- ✅ No external dependencies in generated code

**How it works:**
1. Write SQL queries in `.sql` files
2. Run `sqlc generate` command
3. Get generated Go code with types and methods

---

## 1. Installation & Setup

### Install sqlc:
```bash
go install github.com/sqlc-dev/sqlc/cmd/sqlc@latest
```

### Create `sqlc.yaml` config file:
```yaml
version: "2"
sql:
  - engine: "mysql"
    queries: "internal/repository/queries"
    schema: "internal/repository/schema"
    gen:
      go:
        package: "repository"
        out: "internal/repository/generated"
        sql_package: "database/sql"
        emit_json_tags: true
        emit_prepared_queries: false
        emit_interface: false
        emit_exact_table_names: false
```

---

## 2. SQL Schema Files

### `internal/repository/schema/traffic_tickets.sql`:
```sql
CREATE TABLE traffic_tickets (
    id INT AUTO_INCREMENT PRIMARY KEY,
    detected_speed DOUBLE NOT NULL,
    legal_speed DOUBLE NOT NULL,
    violation_location VARCHAR(255) NOT NULL,
    violation_date VARCHAR(50) NOT NULL,
    violation_time VARCHAR(50) NOT NULL,
    violation_type VARCHAR(100) NOT NULL,
    license_plate_number VARCHAR(20) NOT NULL,
    vehicle_production_id VARCHAR(50) NOT NULL,
    vehicle_factory VARCHAR(100) NOT NULL,
    vehicle_model VARCHAR(100) NOT NULL,
    vehicle_color VARCHAR(50) NOT NULL,
    vehicle_brand VARCHAR(100) NOT NULL,
    officer_name VARCHAR(100) NOT NULL,
    officer_id VARCHAR(50) NOT NULL,
    officer_rank VARCHAR(50) NOT NULL,
    suspect_name VARCHAR(100) NOT NULL,
    suspect_id VARCHAR(50) NOT NULL,
    suspect_age INT NOT NULL,
    officer_age INT NOT NULL,
    suspect_job VARCHAR(100) NOT NULL,
    suspect_address TEXT NOT NULL,
    suspect_birth_place VARCHAR(100) NOT NULL,
    officer_branch_office_address TEXT NOT NULL
);
```

**Note:** sqlc reads this schema to understand table structure and generate types.

---

## 3. SQL Query Files

### `internal/repository/queries/traffic_tickets.sql`:
```sql
-- name: InsertTrafficTicket :execresult
INSERT INTO traffic_tickets (
    detected_speed, legal_speed, violation_location, violation_date, violation_time,
    violation_type, license_plate_number, vehicle_production_id, vehicle_factory, vehicle_model,
    vehicle_color, vehicle_brand, officer_name, officer_id, officer_rank, suspect_name,
    suspect_id, suspect_age, officer_age, suspect_job, suspect_address, suspect_birth_place,
    officer_branch_office_address
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
);

-- name: ListTrafficTickets :many
SELECT * FROM traffic_tickets
ORDER BY id DESC
LIMIT ? OFFSET ?;

-- name: GetPaginatedTrafficTickets :many
SELECT * FROM traffic_tickets
ORDER BY id ASC
LIMIT ? OFFSET ?;
```

**Key Points:**
- `-- name: FunctionName :execresult` - Generates a function that returns `sql.Result`
- `-- name: FunctionName :many` - Generates a function that returns a slice
- `-- name: FunctionName :one` - Generates a function that returns a single row
- `?` placeholders work for MySQL (sqlc handles PostgreSQL `$1`, SQL Server `@param` automatically)

---

## 4. Generate Code

Run:
```bash
sqlc generate
```

This creates generated files in `internal/repository/generated/`

---

## 5. Generated Code (What sqlc Creates)

### `internal/repository/generated/models.go`:
```go
// Code generated by sqlc. DO NOT EDIT.

package repository

type TrafficTicket struct {
	ID                         int32   `json:"id"`
	DetectedSpeed              float64 `json:"detected_speed"`
	LegalSpeed                 float64 `json:"legal_speed"`
	ViolationLocation          string  `json:"violation_location"`
	ViolationDate              string  `json:"violation_date"`
	ViolationTime              string  `json:"violation_time"`
	ViolationType              string  `json:"violation_type"`
	LicensePlateNumber         string  `json:"license_plate_number"`
	VehicleProductionID        string  `json:"vehicle_production_id"`
	VehicleFactory             string  `json:"vehicle_factory"`
	VehicleModel               string  `json:"vehicle_model"`
	VehicleColor               string  `json:"vehicle_color"`
	VehicleBrand               string  `json:"vehicle_brand"`
	OfficerName                string  `json:"officer_name"`
	OfficerID                  string  `json:"officer_id"`
	OfficerRank                string  `json:"officer_rank"`
	SuspectName                string  `json:"suspect_name"`
	SuspectID                  string  `json:"suspect_id"`
	SuspectAge                 int32   `json:"suspect_age"`
	OfficerAge                 int32   `json:"officer_age"`
	SuspectJob                 string  `json:"suspect_job"`
	SuspectAddress             string  `json:"suspect_address"`
	SuspectBirthPlace          string  `json:"suspect_birth_place"`
	OfficerBranchOfficeAddress string  `json:"officer_branch_office_address"`
}
```

**Note:** sqlc automatically:
- Generates struct from SQL schema
- Adds `json` tags automatically
- Uses correct Go types (INT → int32, VARCHAR → string, etc.)

### `internal/repository/generated/traffic_tickets.sql.go`:
```go
// Code generated by sqlc. DO NOT EDIT.

package repository

import (
	"context"
	"database/sql"
)

const insertTrafficTicket = `-- name: InsertTrafficTicket :execresult
INSERT INTO traffic_tickets (
    detected_speed, legal_speed, violation_location, violation_date, violation_time,
    violation_type, license_plate_number, vehicle_production_id, vehicle_factory, vehicle_model,
    vehicle_color, vehicle_brand, officer_name, officer_id, officer_rank, suspect_name,
    suspect_id, suspect_age, officer_age, suspect_job, suspect_address, suspect_birth_place,
    officer_branch_office_address
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)`

type InsertTrafficTicketParams struct {
	DetectedSpeed              float64 `json:"detected_speed"`
	LegalSpeed                 float64 `json:"legal_speed"`
	ViolationLocation          string  `json:"violation_location"`
	ViolationDate              string  `json:"violation_date"`
	ViolationTime              string  `json:"violation_time"`
	ViolationType              string  `json:"violation_type"`
	LicensePlateNumber         string  `json:"license_plate_number"`
	VehicleProductionID        string  `json:"vehicle_production_id"`
	VehicleFactory             string  `json:"vehicle_factory"`
	VehicleModel               string  `json:"vehicle_model"`
	VehicleColor               string  `json:"vehicle_color"`
	VehicleBrand               string  `json:"vehicle_brand"`
	OfficerName                string  `json:"officer_name"`
	OfficerID                  string  `json:"officer_id"`
	OfficerRank                string  `json:"officer_rank"`
	SuspectName                string  `json:"suspect_name"`
	SuspectID                  string  `json:"suspect_id"`
	SuspectAge                 int32   `json:"suspect_age"`
	OfficerAge                 int32   `json:"officer_age"`
	SuspectJob                 string  `json:"suspect_job"`
	SuspectAddress             string  `json:"suspect_address"`
	SuspectBirthPlace          string  `json:"suspect_birth_place"`
	OfficerBranchOfficeAddress string  `json:"officer_branch_office_address"`
}

func (q *Queries) InsertTrafficTicket(ctx context.Context, arg InsertTrafficTicketParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertTrafficTicket,
		arg.DetectedSpeed,
		arg.LegalSpeed,
		arg.ViolationLocation,
		arg.ViolationDate,
		arg.ViolationTime,
		arg.ViolationType,
		arg.LicensePlateNumber,
		arg.VehicleProductionID,
		arg.VehicleFactory,
		arg.VehicleModel,
		arg.VehicleColor,
		arg.VehicleBrand,
		arg.OfficerName,
		arg.OfficerID,
		arg.OfficerRank,
		arg.SuspectName,
		arg.SuspectID,
		arg.SuspectAge,
		arg.OfficerAge,
		arg.SuspectJob,
		arg.SuspectAddress,
		arg.SuspectBirthPlace,
		arg.OfficerBranchOfficeAddress,
	)
}

const listTrafficTickets = `-- name: ListTrafficTickets :many
SELECT * FROM traffic_tickets
ORDER BY id DESC
LIMIT ? OFFSET ?`

type ListTrafficTicketsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListTrafficTickets(ctx context.Context, arg ListTrafficTicketsParams) ([]TrafficTicket, error) {
	rows, err := q.db.QueryContext(ctx, listTrafficTickets, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TrafficTicket
	for rows.Next() {
		var i TrafficTicket
		if err := rows.Scan(
			&i.ID,
			&i.DetectedSpeed,
			&i.LegalSpeed,
			&i.ViolationLocation,
			&i.ViolationDate,
			&i.ViolationTime,
			&i.ViolationType,
			&i.LicensePlateNumber,
			&i.VehicleProductionID,
			&i.VehicleFactory,
			&i.VehicleModel,
			&i.VehicleColor,
			&i.VehicleBrand,
			&i.OfficerName,
			&i.OfficerID,
			&i.OfficerRank,
			&i.SuspectName,
			&i.SuspectID,
			&i.SuspectAge,
			&i.OfficerAge,
			&i.SuspectJob,
			&i.SuspectAddress,
			&i.SuspectBirthPlace,
			&i.OfficerBranchOfficeAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
```

**Key Points:**
- sqlc generates ALL the boilerplate code
- Creates parameter structs automatically
- Handles all field assignments
- Type-safe at compile-time

---

## 6. Repository Implementation - Before vs After

### Before (Current - Manual Implementation):
```go
// internal/repository/mysql_traffic_ticket_repo.go
type MySQLTrafficTicketRepository struct {
	db *sql.DB
}

func (r *MySQLTrafficTicketRepository) Insert(ticket *entities.TrafficTicket) error {
	ctx, cancel := context.WithTimeout(context.Background(), config.GetQueryTimeout())
	defer cancel()

	query := `INSERT INTO traffic_tickets (...) VALUES (?, ?, ...)`
	
	_, err := r.db.ExecContext(ctx, query,
		ticket.DetectedSpeed,        // 23 lines of assignments
		ticket.LegalSpeed,
		// ... 21 more lines
	)
	
	if err != nil {
		log.Printf("[MySQL] InsertTrafficTicket error: %v", err)
		return handleQueryError(err)
	}
	return err
}
```

### After (With sqlc - Thin Wrapper):
```go
// internal/repository/mysql_traffic_ticket_repo.go
import (
	"golang_daerah/internal/repository/generated"
)

type MySQLTrafficTicketRepository struct {
	queries *generated.Queries  // sqlc generated queries
	db      *sql.DB
}

func NewMySQLTrafficTicketRepository(db *sql.DB) *MySQLTrafficTicketRepository {
	return &MySQLTrafficTicketRepository{
		queries: generated.New(db),
		db:      db,
	}
}

func (r *MySQLTrafficTicketRepository) Insert(ticket *entities.TrafficTicket) error {
	ctx, cancel := context.WithTimeout(context.Background(), config.GetQueryTimeout())
	defer cancel()

	// Convert entities.TrafficTicket to generated.InsertTrafficTicketParams
	params := generated.InsertTrafficTicketParams{
		DetectedSpeed:              ticket.DetectedSpeed,
		LegalSpeed:                 ticket.LegalSpeed,
		ViolationLocation:          ticket.ViolationLocation,
		ViolationDate:              ticket.ViolationDate,
		ViolationTime:              ticket.ViolationTime,
		ViolationType:              ticket.ViolationType,
		LicensePlateNumber:         ticket.LicensePlateNumber,
		VehicleProductionID:        ticket.VehicleProductionID,
		VehicleFactory:             ticket.VehicleFactory,
		VehicleModel:               ticket.VehicleModel,
		VehicleColor:               ticket.VehicleColor,
		VehicleBrand:               ticket.VehicleBrand,
		OfficerName:                ticket.OfficerName,
		OfficerID:                  ticket.OfficerID,
		OfficerRank:                ticket.OfficerRank,
		SuspectName:                ticket.SuspectName,
		SuspectID:                  ticket.SuspectID,
		SuspectAge:                 int32(ticket.SuspectAge),
		OfficerAge:                 int32(ticket.OfficerAge),
		SuspectJob:                 ticket.SuspectJob,
		SuspectAddress:             ticket.SuspectAddress,
		SuspectBirthPlace:          ticket.SuspectBirthPlace,
		OfficerBranchOfficeAddress: ticket.OfficerBranchOfficeAddress,
	}

	_, err := r.queries.InsertTrafficTicket(ctx, params)
	if err != nil {
		log.Printf("[MySQL] InsertTrafficTicket error: %v", err)
		return handleQueryError(err)
	}
	return err
}

func (r *MySQLTrafficTicketRepository) List(limit, offset int) ([]*entities.TrafficTicket, error) {
	ctx, cancel := context.WithTimeout(context.Background(), config.GetQueryTimeout())
	defer cancel()

	limit, offset = normalizePagination(limit, offset)

	// Call generated method
	results, err := r.queries.ListTrafficTickets(ctx, generated.ListTrafficTicketsParams{
		Limit:  int32(limit),
		Offset: int32(offset),
	})
	if err != nil {
		return nil, handleQueryError(err)
	}

	// Convert generated.TrafficTicket to entities.TrafficTicket
	tickets := make([]*entities.TrafficTicket, len(results))
	for i, r := range results {
		tickets[i] = &entities.TrafficTicket{
			ID:                         int(r.ID),
			DetectedSpeed:              r.DetectedSpeed,
			LegalSpeed:                 r.LegalSpeed,
			ViolationLocation:          r.ViolationLocation,
			ViolationDate:              r.ViolationDate,
			ViolationTime:              r.ViolationTime,
			ViolationType:              r.ViolationType,
			LicensePlateNumber:         r.LicensePlateNumber,
			VehicleProductionID:        r.VehicleProductionID,
			VehicleFactory:             r.VehicleFactory,
			VehicleModel:               r.VehicleModel,
			VehicleColor:               r.VehicleColor,
			VehicleBrand:               r.VehicleBrand,
			OfficerName:                r.OfficerName,
			OfficerID:                  r.OfficerID,
			OfficerRank:                r.OfficerRank,
			SuspectName:                r.SuspectName,
			SuspectID:                  r.SuspectID,
			SuspectAge:                 int(r.SuspectAge),
			OfficerAge:                 int(r.OfficerAge),
			SuspectJob:                 r.SuspectJob,
			SuspectAddress:             r.SuspectAddress,
			SuspectBirthPlace:          r.SuspectBirthPlace,
			OfficerBranchOfficeAddress: r.OfficerBranchOfficeAddress,
		}
	}

	return tickets, nil
}
```

**Wait, this still has conversion code!** That's because we're keeping `entities.TrafficTicket` separate from `generated.TrafficTicket`.

---

## 7. Better Approach: Use Generated Types Directly

### Option A: Use sqlc generated types as your entities

Instead of maintaining separate `entities` package, use sqlc's generated types:

```go
// internal/repository/mysql_traffic_ticket_repo.go
import (
	"golang_daerah/internal/repository/generated"
)

type MySQLTrafficTicketRepository struct {
	queries *generated.Queries
}

func NewMySQLTrafficTicketRepository(db *sql.DB) *MySQLTrafficTicketRepository {
	return &MySQLTrafficTicketRepository{
		queries: generated.New(db),
	}
}

func (r *MySQLTrafficTicketRepository) Insert(ticket *generated.TrafficTicket) error {
	ctx, cancel := context.WithTimeout(context.Background(), config.GetQueryTimeout())
	defer cancel()

	params := generated.InsertTrafficTicketParams{
		DetectedSpeed:              ticket.DetectedSpeed,
		LegalSpeed:                 ticket.LegalSpeed,
		// ... all fields
	}

	_, err := r.queries.InsertTrafficTicket(ctx, params)
	return handleQueryError(err)
}

func (r *MySQLTrafficTicketRepository) List(limit, offset int) ([]generated.TrafficTicket, error) {
	ctx, cancel := context.WithTimeout(context.Background(), config.GetQueryTimeout())
	defer cancel()

	limit, offset = normalizePagination(limit, offset)

	return r.queries.ListTrafficTickets(ctx, generated.ListTrafficTicketsParams{
		Limit:  int32(limit),
		Offset: int32(offset),
	})
}
```

**Now it's just 3 lines per method!** No field assignments, no scanning code.

---

## 8. Complete Example: All Three Approaches

### Current (Manual - 45 lines):
```go
func (r *MySQLTrafficTicketRepository) Insert(ticket *entities.TrafficTicket) error {
	ctx, cancel := context.WithTimeout(context.Background(), config.GetQueryTimeout())
	defer cancel()

	query := `INSERT INTO traffic_tickets (...) VALUES (?, ?, ...)`
	
	_, err := r.db.ExecContext(ctx, query,
		ticket.DetectedSpeed,
		ticket.LegalSpeed,
		// ... 21 more lines
	)
	
	if err != nil {
		log.Printf("[MySQL] InsertTrafficTicket error: %v", err)
		return handleQueryError(err)
	}
	return err
}
```

### With sqlc (Using generated types - 8 lines):
```go
func (r *MySQLTrafficTicketRepository) Insert(ticket *generated.TrafficTicket) error {
	ctx, cancel := context.WithTimeout(context.Background(), config.GetQueryTimeout())
	defer cancel()

	params := generated.InsertTrafficTicketParams{
		DetectedSpeed: ticket.DetectedSpeed,
		LegalSpeed:    ticket.LegalSpeed,
		// ... all fields (but struct literal, not function args)
	}

	_, err := r.queries.InsertTrafficTicket(ctx, params)
	return handleQueryError(err)
}
```

### With Reflection (No tags - 15 lines):
```go
func (r *MySQLTrafficTicketRepository) Insert(ticket *entities.TrafficTicket) error {
	ctx, cancel := context.WithTimeout(context.Background(), config.GetQueryTimeout())
	defer cancel()

	values, columns, err := getStructFieldValues(ticket)
	if err != nil {
		return err
	}

	placeholders := strings.Repeat("?, ", len(values))
	placeholders = placeholders[:len(placeholders)-2]
	columnList := strings.Join(columns, ", ")
	
	query := fmt.Sprintf("INSERT INTO traffic_tickets (%s) VALUES (%s)", columnList, placeholders)
	_, err = r.db.ExecContext(ctx, query, values...)
	return handleQueryError(err)
}
```

---

## 9. Comparison Table

| Feature | Manual | sqlx | Reflection | sqlc |
|---------|--------|------|------------|------|
| Entity redundancy | ❌ Manual | ⚠️ Needs `db` tags | ✅ No tags | ✅ Generated |
| Repo redundancy | ❌ 20+ lines | ✅ 1 line | ✅ 5 lines | ✅ 3 lines |
| Type safety | ✅ | ✅ | ⚠️ Runtime | ✅ Compile-time |
| Performance | ✅ | ✅ | ⚠️ Reflection | ✅ No overhead |
| External deps | ✅ None | ❌ sqlx | ✅ None | ⚠️ Build tool |
| Maintainability | ❌ Manual updates | ✅ Good | ✅ Excellent | ✅ Excellent |
| Learning curve | ✅ Easy | ✅ Easy | ⚠️ Medium | ⚠️ Medium |

---

## 10. SQLC Workflow

### Development Workflow:
1. **Write SQL queries** in `.sql` files
2. **Run `sqlc generate`** to generate Go code
3. **Use generated code** in your repositories
4. **Commit generated code** to git (or add to `.gitignore`)

### When Schema Changes:
1. Update SQL schema file
2. Update SQL query file
3. Run `sqlc generate`
4. Fix any compilation errors (type mismatches)
5. Done!

---

## 11. Multi-Database Support

sqlc can generate code for multiple databases:

### `sqlc.yaml`:
```yaml
version: "2"
sql:
  - engine: "postgresql"
    queries: "internal/repository/queries/postgres"
    schema: "internal/repository/schema/postgres"
    gen:
      go:
        package: "repository"
        out: "internal/repository/generated/postgres"
  
  - engine: "mysql"
    queries: "internal/repository/queries/mysql"
    schema: "internal/repository/schema/mysql"
    gen:
      go:
        package: "repository"
        out: "internal/repository/generated/mysql"
  
  - engine: "sqlserver"
    queries: "internal/repository/queries/sqlserver"
    schema: "internal/repository/schema/sqlserver"
    gen:
      go:
        package: "repository"
        out: "internal/repository/generated/sqlserver"
```

Each database gets its own generated code!

---

## 12. Pros & Cons

### Pros:
- ✅ **Zero redundancy** - All code is generated
- ✅ **Type-safe** - Compile-time checking
- ✅ **No runtime overhead** - No reflection
- ✅ **SQL-first** - Write SQL, get Go code
- ✅ **Multi-database** - One SQL file per database
- ✅ **Version controlled** - Generated code can be committed

### Cons:
- ⚠️ **Build step required** - Must run `sqlc generate`
- ⚠️ **Learning curve** - Need to learn sqlc syntax
- ⚠️ **Type conversion** - If keeping separate entities, need conversion layer
- ⚠️ **SQL in files** - Queries live in `.sql` files, not Go code

---

## 13. Recommendation

**Use sqlc if:**
- ✅ You want maximum type safety
- ✅ You're comfortable with SQL-first approach
- ✅ You want zero runtime overhead
- ✅ You can add a build step to your workflow

**Use Reflection if:**
- ✅ You want to keep existing entity structs
- ✅ You want no external dependencies
- ✅ You want flexibility without build steps
- ✅ Minimal runtime overhead is acceptable

---

## 14. Example: Complete Repository with sqlc

```go
// internal/repository/mysql_traffic_ticket_repo.go
package repository

import (
	"context"
	"golang_daerah/config"
	"golang_daerah/internal/repository/generated"
)

type MySQLTrafficTicketRepository struct {
	queries *generated.Queries
}

func NewMySQLTrafficTicketRepository(db *sql.DB) *MySQLTrafficTicketRepository {
	return &MySQLTrafficTicketRepository{
		queries: generated.New(db),
	}
}

func (r *MySQLTrafficTicketRepository) Insert(ticket *generated.TrafficTicket) error {
	ctx, cancel := context.WithTimeout(context.Background(), config.GetQueryTimeout())
	defer cancel()

	params := generated.InsertTrafficTicketParams{
		DetectedSpeed:              ticket.DetectedSpeed,
		LegalSpeed:                 ticket.LegalSpeed,
		ViolationLocation:          ticket.ViolationLocation,
		ViolationDate:              ticket.ViolationDate,
		ViolationTime:              ticket.ViolationTime,
		ViolationType:              ticket.ViolationType,
		LicensePlateNumber:         ticket.LicensePlateNumber,
		VehicleProductionID:        ticket.VehicleProductionID,
		VehicleFactory:             ticket.VehicleFactory,
		VehicleModel:               ticket.VehicleModel,
		VehicleColor:               ticket.VehicleColor,
		VehicleBrand:               ticket.VehicleBrand,
		OfficerName:                ticket.OfficerName,
		OfficerID:                  ticket.OfficerID,
		OfficerRank:                ticket.OfficerRank,
		SuspectName:                ticket.SuspectName,
		SuspectID:                  ticket.SuspectID,
		SuspectAge:                 ticket.SuspectAge,
		OfficerAge:                 ticket.OfficerAge,
		SuspectJob:                 ticket.SuspectJob,
		SuspectAddress:             ticket.SuspectAddress,
		SuspectBirthPlace:          ticket.SuspectBirthPlace,
		OfficerBranchOfficeAddress: ticket.OfficerBranchOfficeAddress,
	}

	_, err := r.queries.InsertTrafficTicket(ctx, params)
	return handleQueryError(err)
}

func (r *MySQLTrafficTicketRepository) List(limit, offset int) ([]generated.TrafficTicket, error) {
	ctx, cancel := context.WithTimeout(context.Background(), config.GetQueryTimeout())
	defer cancel()

	limit, offset = normalizePagination(limit, offset)

	return r.queries.ListTrafficTickets(ctx, generated.ListTrafficTicketsParams{
		Limit:  int32(limit),
		Offset: int32(offset),
	})
}

func (r *MySQLTrafficTicketRepository) GetPaginated(limit, offset int) ([]generated.TrafficTicket, error) {
	ctx, cancel := context.WithTimeout(context.Background(), config.GetQueryTimeout())
	defer cancel()

	limit, offset = normalizePagination(limit, offset)

	return r.queries.GetPaginatedTrafficTickets(ctx, generated.GetPaginatedTrafficTicketsParams{
		Limit:  int32(limit),
		Offset: int32(offset),
	})
}
```

**Total: ~50 lines for all 3 methods** (vs ~135 lines manually)

---

## Questions?

sqlc is powerful but requires:
- Learning sqlc syntax
- Adding build step (`sqlc generate`)
- Potentially restructuring to use generated types

Would you like me to show a complete implementation example, or do you prefer the reflection approach?

